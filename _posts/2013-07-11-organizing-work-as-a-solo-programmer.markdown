---
layout: post
status: publish
published: true
title: Organizing Work as a Solo Programmer
author: Jeff
author_login: admin
author_email: jeff@allthingsdork.com
author_url: http://www.allthingsdork.com
wordpress_id: 792
wordpress_url: http://www.allthingsdork.com/?p=792
date: '2013-07-11 09:13:46 -0500'
date_gmt: '2013-07-11 15:13:46 -0500'
categories:
- Tech
tags:
- programming
- bug tracking
- self-taught programmer
comments: []
---
<p>In a team environment, you have things like bug reporting, feature request management,<a href="http://www.allaboutagile.com/what-is-agile-10-key-principles/">Agile</a> approaches and sprints. If you're lucky you might even have a dedicated <a href="http://www.youtube.com/watch?v=HsB0UZR7XvE">Scrum Master and Product Owner</a>. But when it's just you, the idea of these sorts of constructs seems like overkill. Nothing could be further from the truth. Documenting your approach applies a type of structure that will reap huge benefits, not necessarily in the quality of your code, but in the productivity of your coding sessions.</p></p>
<h2>Requirements Tracking</h2></p>
<p>If you're using <a href="http://www.github.com">Github</a> there is a feature of the site to track "Issues" for your project. Issues is probably a bad name for it though, because with a little metadata/label magic, it can track features, enhancements, etc. When I started working on my little side project, I setup a list of "requirements" that I needed for my first release. I have entries like:</p></p>
<ul>
<li>Users can sort players by Fantasy Points</li>
<li>Users can filter by position</li>
<li>Users can enter their own stat projections for calculations</li>
<li>Users can create their own draft board</li><br />
</ul></p>
<p>These are just a few examples, but you get the idea. Once these requirements start to take form, you'll quickly realize it'll take forever for you to actually be able to release anything. That's where milestones come in. In Github you can use Milestones to group requirements and issues for a particular release. This gives you small victories along your path to awesomeness.</p></p>
<h2>Issue Tracking</h2></p>
<p>As I go through my testing, I inevitably find bugs. But sometimes I'm on a roll in a certain mode of thinking and don't want to have to context switch to deal with this new problem. This is where I use Github's Issues to log anything and everything I need to go back and address. This is nice for a number of reasons.</p></p>
<ul>
<li>I'll never forget an issue that I need to address</li>
<li>I can begin to see large trends in my code based on the type of issues I'm encountering</li>
<li>I can collect bugs and deal with them in a "bug release"</li>
<li>It builds discrete units of works for commits</li><br />
</ul></p>
<p>That last line is a big one. Prior to my discovery of the usefulness of this type of tracking, my commits were haphazard at best. My commits were largely just ways to save my code changes. You know you've got this problem if you always struggle with your commit messages. If you don't know what to type in a commit, then chances are you're not breaking your work up effectively. With issues and requirements, when to commit becomes automatic. You finish with an issue, you make a commit and push it. You finish a feature request, you commit and push it to the remote repo. Easy as pie.</p></p>
<h2>Planning Your Workday</h2></p>
<p>When your tracking requirements and issues, it makes your coding sessions more productive. If you're like me, you don't program full time, so you spend your nights and weekends coding your brains out. Because of that, you need to make your time as effective and efficient as possible. When you track your requirements, issues, etc in this manor you can simply sit down, look at the outstanding items, pick 2 or 3 and get to work. You'll want to keep in mind the difficulty of the issues your tackling and the time you have for this particular working session. It might be better to tackle a bunch of smaller issues (and get them finished) than half-starting a larger issue. But either approach you take, you'll be ready to tackle the work day.</p></p>
<p>To some folks these may seem like a no brainer. But for the solo programmer, the things suggested here may sound like overkill. The image of the keyboard cowboy hacking away and addressing issues as they spring up may sound sexy. You might even be delusional enough to think you won't run into issues and therefore don't need issue tracking. But either way, I beg you to try this approach and see if it benefits you. I know it has completely changed the way I work and how much work I get done.</p></p>
